// services/ai/image/generator.js
import { Modality } from "@google/genai";
import { getGeminiClient } from "../client.js";

/**
 * Generate an image using Gemini's image generation capabilities
 * @param {string} prompt - Text prompt describing the image to generate
 * @returns {Promise<Object>} - Object containing the generated image data and descriptive text
 */
export async function generateImage(prompt) {
  try {
    console.log(`[Image Generation] Generating image with prompt: "${prompt.substring(0, 100)}${prompt.length > 100 ? '...' : ''}"`);
    
    const ai = await getGeminiClient();
    
    // Set up the request to Gemini
    const response = await ai.models.generateContent({
      model: "gemini-2.0-flash-preview-image-generation",
      contents: prompt,
      config: {
        responseModalities: [Modality.TEXT, Modality.IMAGE],
        temperature: 0.8,
      },
    });
    
    let resultText = '';
    let imageData = null;
    
    // Process the response
    for (const part of response.candidates[0].content.parts) {
      if (part.text) {
        resultText = part.text;
        console.log(`[Image Generation] Model description: ${resultText.substring(0, 100)}${resultText.length > 100 ? '...' : ''}`);
      } else if (part.inlineData) {
        imageData = part.inlineData.data;
        console.log(`[Image Generation] Image data received: ${imageData.substring(0, 20)}...`);
      }
    }
    
    if (!imageData) {
      throw new Error("No image was generated by the model");
    }
    
    // Return both the image data and any accompanying text
    return {
      success: true,
      imageData,
      mimeType: "image/png",
      description: resultText,
      timestamp: new Date().toISOString()
    };
  } catch (error) {
    console.error("[Image Generation] Error generating image:", error);
    return {
      success: false,
      error: error.message || "Failed to generate image",
    };
  }
}

/**
 * Edit an existing image based on a prompt
 * @param {string} prompt - Text prompt describing the desired edits
 * @param {string} baseImageData - Base64 encoded image data to be edited
 * @param {string} mimeType - MIME type of the image (e.g., "image/png")
 * @returns {Promise<Object>} - Object containing the edited image data and descriptive text
 */
export async function editImage(prompt, baseImageData, mimeType = "image/png") {
  try {
    console.log(`[Image Editing] Editing image with prompt: "${prompt.substring(0, 100)}${prompt.length > 100 ? '...' : ''}"`);
    
    const ai = await getGeminiClient();
    
    // Prepare the content parts
    const contents = [
      { text: prompt },
      {
        inlineData: {
          mimeType,
          data: baseImageData,
        },
      },
    ];
    
    // Set up the request to Gemini
    const response = await ai.models.generateContent({
      model: "gemini-2.0-flash-preview-image-generation",
      contents,
      config: {
        responseModalities: [Modality.TEXT, Modality.IMAGE],
        temperature: 0.8,
      },
    });
    
    let resultText = '';
    let imageData = null;
    
    // Process the response
    for (const part of response.candidates[0].content.parts) {
      if (part.text) {
        resultText = part.text;
        console.log(`[Image Editing] Model description: ${resultText.substring(0, 100)}${resultText.length > 100 ? '...' : ''}`);
      } else if (part.inlineData) {
        imageData = part.inlineData.data;
        console.log(`[Image Editing] Image data received: ${imageData.substring(0, 20)}...`);
      }
    }
    
    if (!imageData) {
      throw new Error("No image was generated by the model");
    }
    
    // Return both the image data and any accompanying text
    return {
      success: true,
      imageData,
      mimeType: "image/png",
      description: resultText,
      timestamp: new Date().toISOString()
    };
  } catch (error) {
    console.error("[Image Editing] Error editing image:", error);
    return {
      success: false,
      error: error.message || "Failed to edit image",
    };
  }
}