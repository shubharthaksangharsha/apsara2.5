// services/ai/image/generator.js
import { Modality } from "@google/genai";
import { getGeminiClient } from "../client.js";

/**
 * Generate an image using Gemini's image generation capabilities
 * @param {string} prompt - Text prompt describing the image to generate
 * @returns {Promise<Object>} - Object containing the generated image data and descriptive text
 */
export async function generateImage(prompt) {
  try {
    console.log(`[Image Generation] Generating image with prompt: "${prompt.substring(0, 100)}${prompt.length > 100 ? '...' : ''}"`);
    
    const ai = await getGeminiClient();
    
    // Set up the request to Gemini
    const response = await ai.models.generateContent({
      model: "gemini-2.0-flash-preview-image-generation",
      contents: prompt,
      config: {
        responseModalities: [Modality.TEXT, Modality.IMAGE],
        temperature: 0.8,
      },
    });
    
    let resultText = '';
    let imageData = null;
    
    // Process the response
    for (const part of response.candidates[0].content.parts) {
      if (part.text) {
        resultText = part.text;
        console.log(`[Image Generation] Model description: ${resultText.substring(0, 100)}${resultText.length > 100 ? '...' : ''}`);
      } else if (part.inlineData) {
        imageData = part.inlineData.data;
        console.log(`[Image Generation] Image data received: ${imageData.substring(0, 20)}...`);
      }
    }
    
    if (!imageData) {
      throw new Error("No image was generated by the model");
    }
    
    // Return both the image data and any accompanying text
    return {
      success: true,
      imageData,
      mimeType: "image/png",
      description: resultText,
      timestamp: new Date().toISOString()
    };
  } catch (error) {
    console.error("[Image Generation] Error generating image:", error);
    return {
      success: false,
      error: error.message || "Failed to generate image",
    };
  }
}

/**
 * Edit an existing image based on a prompt
 * @param {string} prompt - Text prompt describing the desired edits
 * @param {string} baseImageData - Base64 encoded image data to be edited
 * @param {string} mimeType - MIME type of the image (e.g., "image/png")
 * @param {Array} userUploadedImages - Array of user uploaded images that might be used for editing
 * @returns {Promise<Object>} - Object containing the edited image data and descriptive text
 */
export async function editImage(prompt, baseImageData, mimeType = "image/png", userUploadedImages = []) {
  try {
    console.log(`[Image Editing] Editing image with prompt: "${prompt.substring(0, 100)}${prompt.length > 100 ? '...' : ''}"`);
    
    const ai = await getGeminiClient();
    
    // Determine which image to use for editing
    let imageToEdit = baseImageData;
    let imageToEditMimeType = mimeType;
    
    // Always prioritize user-uploaded images if available
    if (userUploadedImages && userUploadedImages.length > 0) {
      console.log(`[Image Editing] User uploaded images found (${userUploadedImages.length}), using first uploaded image for editing`);
      // Use the first user-uploaded image
      const userImage = userUploadedImages[0];
      if (userImage.data) {
        // Check if the data is a string (likely a URI or base64 data)
        if (typeof userImage.data === 'string') {
          console.log(`[Image Editing] User uploaded image data is a string, using as-is`);
          imageToEdit = userImage.data;
        } else {
          console.log(`[Image Editing] User uploaded image data is not a string, attempting to convert`);
          // Handle potential object or buffer data
          try {
            imageToEdit = JSON.stringify(userImage.data);
            console.log(`[Image Editing] Converted user uploaded image data to string`);
          } catch (e) {
            console.error(`[Image Editing] Failed to convert user image data:`, e);
            // Fall back to using the stored image
            console.log(`[Image Editing] Falling back to previously stored image`);
            imageToEdit = baseImageData;
          }
        }
        imageToEditMimeType = userImage.mimeType || "image/png";
        console.log(`[Image Editing] Selected user uploaded image with mime type: ${imageToEditMimeType}`);
      } else {
        console.log(`[Image Editing] User uploaded image has no data, falling back to previously stored image`);
      }
    } else {
      console.log(`[Image Editing] No user uploaded images found, using previously stored image`);
    }
    
    // Prepare the content parts
    const contents = [
      { text: prompt },
      {
        inlineData: {
          mimeType: imageToEditMimeType,
          data: imageToEdit,
        },
      },
    ];
    
    // Log the content parts for debugging
    console.log(`[Image Editing] Content parts structure:`, {
      textPartLength: prompt.length,
      imagePartPresent: !!imageToEdit,
      imageDataLength: imageToEdit ? imageToEdit.length : 0,
      mimeType: imageToEditMimeType
    });
    
    // Set up the request to Gemini
    const response = await ai.models.generateContent({
      model: "gemini-2.0-flash-preview-image-generation",
      contents,
      config: {
        responseModalities: [Modality.TEXT, Modality.IMAGE],
        temperature: 0.8,
      },
    });
    
    let resultText = '';
    let imageData = null;
    
    // Process the response
    for (const part of response.candidates[0].content.parts) {
      if (part.text) {
        resultText = part.text;
        console.log(`[Image Editing] Model description: ${resultText.substring(0, 100)}${resultText.length > 100 ? '...' : ''}`);
      } else if (part.inlineData) {
        imageData = part.inlineData.data;
        console.log(`[Image Editing] Image data received: ${imageData.substring(0, 20)}...`);
      }
    }
    
    if (!imageData) {
      throw new Error("No image was generated by the model");
    }
    
    // Return both the image data and any accompanying text
    return {
      success: true,
      imageData,
      mimeType: "image/png",
      description: resultText,
      timestamp: new Date().toISOString()
    };
  } catch (error) {
    console.error("[Image Editing] Error editing image:", error);
    return {
      success: false,
      error: error.message || "Failed to edit image",
    };
  }
}